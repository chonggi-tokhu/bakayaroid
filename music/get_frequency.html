<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Pitch Detection</title>
</head>

<body>
    <audio src="../FluidR3_GM/light_yagami-mp3/C4.mp3" controls loop></audio>
    <h1>Frequency (Hz)</h1>
    <h2 id="frequency">0.0</h2>
    <div>
        <button onclick="startPitchDetection()">
            Start Pitch Detection
        </button>
    </div>
    <script>
        var audioCtx = null;
        var microphoneStream = null;
        var analyserNode = null;
        var audioData = null;
        var corrolatedSignal = null;
        var localMaxima = new Array(10);
        const frequencyDisplayElement = document.querySelector('#frequency');
        function init() {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            microphoneStream = null;
            analyserNode = audioCtx.createAnalyser();
            audioData = new Float32Array(analyserNode.fftSize);
            corrolatedSignal = new Float32Array(analyserNode.fftSize);
        }
        function startPitchDetection() {
            init();

            var stream = document.getElementsByTagName("audio")[0].captureStream(60);
            console.log(stream);
            microphoneStream = audioCtx.createMediaStreamSource(stream);
            microphoneStream.connect(analyserNode);

            audioData = new Float32Array(analyserNode.fftSize);
            corrolatedSignal = new Float32Array(analyserNode.fftSize);

            setInterval(() => {
                analyserNode.getFloatTimeDomainData(audioData);

                var pitch = getAutocorrolatedPitch();

                frequencyDisplayElement.innerHTML = `${pitch}`;
            }, 300);
        }

        function getAutocorrolatedPitch() {
            // First: autocorrolate the signal

            var maximaCount = 0;

            for (var l = 0; l < analyserNode.fftSize; l++) {
                corrolatedSignal[l] = 0;
                for (var i = 0; i < analyserNode.fftSize - l; i++) {
                    corrolatedSignal[l] += audioData[i] * audioData[i + l];
                }
                if (l > 1) {
                    if ((corrolatedSignal[l - 2] - corrolatedSignal[l - 1]) < 0
                        && (corrolatedSignal[l - 1] - corrolatedSignal[l]) > 0) {
                        localMaxima[maximaCount] = (l - 1);
                        maximaCount++;
                        if ((maximaCount >= localMaxima.length))
                            break;
                    }
                }
            }

            // Second: find the average distance in samples between maxima

            var maximaMean = localMaxima[0];

            for (var i = 1; i < maximaCount; i++)
                maximaMean += localMaxima[i] - localMaxima[i - 1];

            maximaMean /= maximaCount;

            return audioCtx.sampleRate / maximaMean;
        }
    </script>
</body>

</html>